# mqlite Configuration Example
# Copy this file to mqlite.toml and customize as needed
#
# Environment Variables:
#
# 1. In-file substitution using ${VAR} or ${VAR:-default} syntax:
#    bind = "${MQTT_HOST:-0.0.0.0}:${MQTT_PORT:-1883}"
#    password = "${ADMIN_PASSWORD}"
#
# 2. Override any field with MQLITE__ prefixed env vars (double underscore):
#    MQLITE__SERVER__BIND=0.0.0.0:1884
#    MQLITE__LIMITS__MAX_CONNECTIONS=50000
#    MQLITE__MQTT__MAX_QOS=1
#    MQLITE__LOG__LEVEL=debug

[log]
# Log level: error, warn, info, debug, trace
level = "info"

[server]
# TCP bind address for MQTT connections
bind = "0.0.0.0:1883"
# Number of worker threads (0 = auto, uses CPU count)
workers = 0
# $SYS topic publish interval in seconds (0 = disabled)
sys_interval = 10

# PROXY Protocol Configuration (HAProxy PROXY protocol v1/v2)
# Enable when running behind a load balancer that sends PROXY headers.
# This preserves real client IP addresses through the proxy layer.
# When enabled, connections without a valid PROXY header are rejected.
#
# [server.proxy_protocol]
# enabled = true
# timeout_secs = 5

[limits]
# Note: Set any limit to 0 for unbounded (where applicable)

# Maximum number of concurrent connections (default: 100000)
max_connections = 100000

# Maximum MQTT packet size in bytes (default: 1048576 = 1MB)
# Packets exceeding this are rejected. Advertised in CONNACK for MQTT 5.
max_packet_size = 1048576

# Maximum topic name length in bytes (default: 4096)
max_topic_length = 4096

# Maximum topic levels (depth) allowed (default: 32)
# Topic levels are separated by '/'. For example, "a/b/c" has 3 levels.
# Prevents subscription trie explosion from deeply nested wildcards.
max_topic_levels = 32

# Receive Maximum: max unacked QoS 1/2 messages we accept from a client (default: 65535)
# Advertised in CONNACK. Client exceeding this gets disconnected.
receive_maximum = 65535

# Topic Alias Maximum: max topic aliases per client (default: 0 = disabled)
# Advertised in CONNACK for MQTT 5.
topic_alias_maximum = 0

# Per-client write buffer soft limit in bytes (default: 1048576 = 1MB)
# When exceeded, QoS 0 messages are dropped (backpressure).
client_write_buffer_size = 1048576

# Maximum in-flight QoS 1/2 messages per client (broker -> client) (default: 32)
# Respects client's Receive Maximum if lower.
max_inflight = 32

[session]
# Default keep alive in seconds (used when client sends 0)
default_keep_alive = 60

# Maximum keep alive in seconds (client value capped to this)
max_keep_alive = 65535

# Maximum topic aliases per client (MQTT v5)
max_topic_aliases = 0

[mqtt]
# Maximum QoS level (0, 1, or 2)
max_qos = 2

# Whether retained messages are available
retain_available = true

# Whether wildcard subscriptions are available
wildcard_subscriptions = true

# Whether subscription identifiers are available (MQTT v5)
subscription_identifiers = true

# Whether shared subscriptions are available
shared_subscriptions = true

# === Authentication ===
# Static user authentication with plaintext passwords (dev) or argon2 hashes (production)

[auth]
# Enable authentication (default: false)
enabled = false

# Allow anonymous connections when auth is enabled (default: false)
# If true, clients without credentials use ACL anonymous permissions
allow_anonymous = false

# Static user list - use password_hash for production!
# Generate password hashes with: echo -n "password" | argon2 $(openssl rand -base64 16) -id -e
#
# [[auth.users]]
# username = "admin"
# password = "secret"  # Use only for development!
# # password_hash = "$argon2id$v=19$..."  # Use for production
# role = "admin"
#
# [[auth.users]]
# username = "device001"
# password_hash = "${DEVICE_PASSWORD_HASH}"  # env var substitution
# role = "device"

# === Access Control List (ACL) ===
# Topic-based authorization with pattern matching

[acl]
# Enable ACL (default: false)
enabled = false

# Role definitions with publish/subscribe patterns
# Patterns support:
# - MQTT wildcards: + (single level), # (multi-level)
# - Variable substitution: %c (client_id), %u (username)
#
# [[acl.roles]]
# name = "admin"
# publish = ["#"]
# subscribe = ["#"]
#
# [[acl.roles]]
# name = "device"
# publish = ["sensors/%c/#"]       # Devices publish to their own topic tree
# subscribe = ["commands/%c/#"]    # Devices receive commands on their topic

# Default permissions for authenticated users without an explicit role
[acl.default]
publish = []
subscribe = ["$SYS/#"]

# Permissions for anonymous (unauthenticated) connections
# Only applies when auth.allow_anonymous = true
[acl.anonymous]
publish = ["public/#"]
subscribe = ["public/#", "$SYS/#"]

# === Prometheus Metrics ===
# Exposes broker metrics in Prometheus exposition format

[prometheus]
# Enable Prometheus metrics endpoint (default: false)
enabled = true
# HTTP bind address for /metrics endpoint (default: 127.0.0.1:9090)
bind = "0.0.0.0:9090"

# === TLS Configuration ===
# Secure MQTT connections on port 8883

[tls]
# Enable TLS listener (default: false)
enabled = false
# TLS bind address (default: 0.0.0.0:8883)
bind = "0.0.0.0:8883"
# Path to PEM-encoded certificate file
cert = "/etc/mqlite/certs/cert.pem"
# Path to PEM-encoded private key file
key = "/etc/mqlite/certs/key.pem"

# PROXY Protocol Configuration for TLS listener
# Note: PROXY header is parsed on the raw socket BEFORE TLS handshake
#
# [tls.proxy_protocol]
# enabled = true
# timeout_secs = 5

# Generate self-signed certs for testing:
# openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes

# === Bridge Configuration ===
# Connect to remote MQTT brokers and sync messages bidirectionally.
# Each bridge publishes stats to $SYS/broker/bridge/<name>/...

# [[bridge]]
# name = "cloud"                              # Used in $SYS topics
# address = "mqtt.example.com:8883"
#
# # Authentication
# remote_username = "bridge-user"
# remote_password = "${BRIDGE_PASSWORD}"
# local_username = "bridge-cloud"             # Identity for local ACL
#
# # Protocol
# protocol_version = "mqtt5"                  # mqtt311 | mqtt5
# keepalive = 60
# clean_start = true
# clientid_prefix = "mqlite-bridge"
#
# # TLS (optional)
# tls = true
# ca_file = "/etc/mqlite/ca.pem"
# # tls_insecure = false                      # Skip cert verification (dangerous)
#
# # Topic routing - subscribe pulls remote→local, publish pushes local→remote
# [[bridge.subscribe]]
# topic = "remote/sensors/#"
# qos = 1
#
# [[bridge.publish]]
# topic = "local/commands/#"
# qos = 1
#
# # Topic prefixing (optional)
# local_prefix = "cloud/"                     # Prepend to incoming topics
# # remote_prefix = ""                        # Prepend to outgoing topics
#
# # Reconnection
# reconnect_delay = 5                         # Initial delay (seconds)
# reconnect_max = 300                         # Max delay with exponential backoff

# --- Future Configuration Sections (not yet implemented) ---
#
# [websocket]
# bind = "0.0.0.0:9001"
# path = "/mqtt"
#
# [persistence]
# enabled = true
# backend = "sqlite"
# path = "/var/lib/mqlite"
